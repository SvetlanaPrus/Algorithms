function binarySearch (value, arr){
arr.sort((a, b) => a - b);                                     //*** Make sure to sort array before use it ***//
let firstIndex = 0, lastIndex = arr.length-1, middleIndex;
let found = false;
while (found === false & firstIndex <= lastIndex) {
  middleIndex = Math.floor((firstIndex + lastIndex)/2); 
  if (value === arr[middleIndex]) {
    found = true;
  } else if (value < arr[middleIndex]){
    lastIndex = middleIndex - 1;   
  } else {
    firstIndex = middleIndex + 1;  
  }
}
return middleIndex;
}


console.log(binarySearch (11, [1, 2, 85, 56, 42, 11, 23, 45, 18, 25, 6, 56, 114]))


Для поиска значения вы сначала сравниваете значение со средним элементом списка. 
Если они равны, значение поиска найдено. Если значение поиска больше, чем средний элемент, выполняется поиск в верхней половине данных. 
Затем вы сравниваете средний элемент этого раздела со значением поиска. 
В качестве альтернативы, если элемент меньше среднего элемента, вы ищете в нижней половине списка и сравниваете его среднее значение. 
Список многократно делится пополам до тех пор, пока элемент не будет найден или не останется элементов для поиска.

Алгоритм линейного поиска проще и не требует отсортированного массива. Тем не менее, это неэффективно для использования с большими массивами. 
В худшем случае алгоритм должен будет искать все элементы, сравнивая их по n (где n - количество элементов).

С другой стороны, алгоритм двоичного поиска требует, чтобы вы сначала отсортировали массив, и его сложнее реализовать. 
Тем не менее, это более эффективно, даже если учитывать стоимость сортировки. 
Например, массив с 10 элементами будет делать не более 4 сравнений для бинарного поиска против 10 для линейного поиска - не такое большое улучшение. 
Однако для массива с 1 000 000 элементов наихудший случай в бинарном поиске - всего 20 сравнений. Это огромное улучшение по сравнению с линейным поиском!




